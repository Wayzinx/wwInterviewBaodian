## 数据库篇
### 1、SQL语句中where与 having的区别
在 SQL 查询中，**WHERE 和 HAVING 都是用于筛选数据的关键字**，但它们的使用场景和作用不同。
1. WHERE
**WHERE 关键字通常用于在查询语句中对行进行筛选**，用于筛选符合特定条件的行。它通常用于过滤基础数据，例如：`SELECT * FROM teachers WHERE city = '深圳';`
在这个例子中，WHERE 子句用于仅返回居住在深圳的讲师的行记录。
2. HAVING
**HAVING 关键字通常用于在 GROUP BY 子句中对聚合函数进行筛选**。它用于在查询返回之后，对返回的数据进行筛选，
例如：`SELECT city, COUNT(*) as count FROM teachers GROUP BY city HAVING COUNT(*) > 10;`
在这个例子中，HAVING 子句用于仅返回拥有超过 10 名讲师的城市。
在总体上，WHERE 和 HAVING 都是用于筛选数据的关键字，但它们的使用场景和作用不同。==**WHERE 用于过滤基础数据，HAVING 用于对聚合函数进行筛选**==。
### 2、SQL语句中IN与EXISTS的区别
在 SQL 查询中，IN 和 EXISTS 都是用于子查询的关键字，但它们的使用场景和作用不同。
- `IN`
**IN 关键字用于查询一个值是否存在于一个集合中**。
例如：`SELECT * FROM students WHERE city IN ('北京', '深圳');`
在上面例子中，`IN` 子句用于返回来自北京或深圳的学生的记录行。
- `EXISTS`
**EXISTS 关键字用于判断子查询是否返回任何行**。
例如：`SELECT * FROM homeworks h WHERE EXISTS (   SELECT * FROM students s   WHERE s.student_id = h.student_id   AND s.city = '北京' );`
在上面上面例子中，`EXISTS` 子句用于返回与来自北京的学生相关联的所有作业的记录行。
可以看到，==**`IN` 用于查询一个值是否存在于一个集合中，而 `EXISTS` 用于判断子查询是否返回任何行**==。它们的使用场景和作用不同，可以根据需要选择使用哪种关键字。
### 3、数据库表删除操作，delete，drop，truncate的区别
**delete，drop，truncate的区别**
`DELETE` 、`DROP` 和`TRUNCATE` 都是 SQL 中用于删除数据的命令，但它们的作用和使用方式有所不同。
**DELETE**
- `DELETE` ：用于删除表中的记录，不删除表本身，可以带上 `WHERE` 子句来指定删除条件。
- 例如：`DELETE FROM table_name WHERE condition;`
这条语句将会删除 `table_name` 表中满足 `condition` 条件的记录。
**DROP**
- `DROP` ：用于删除整个表，包括表结构和数据，慎重使用。
- 例如：`DROP TABLE table_name;`
这条语句将会删除 `table_name` 表及其所有数据和结构。
**TRUNCATE**
- `TRUNCATE` ：用于删除表中的所有数据，但保留表结构，效率较高，不可以带上 `WHERE` 子句。
- 例如：`TRUNCATE TABLE table_name;`
这条语句将会删除 `table_name` 表中的所有数据，但不删除表结构。
**总结**
需要注意的是，使用 `DROP` 和 `TRUNCATE` 命令都会删除表中的所有数据，但它们的执行速度和效率有所不同。一般来说，`TRUNCATE` 命令的执行速度要比 `DELETE` 命令快得多，因为它不会记录每一行被删除的日志，而是直接删除整个表。但是，如果要删除部分数据，或者需要使用 `WHERE` 子句来指定删除条件，就需要使用 `DELETE` 命令了。
### 4、什么是慢查询？慢查询的原因是什么？如何做慢查询的调优呢？
**慢查询是数据库查询执行时间超过预定时间阈值的查询**。这个阈值可以根据应用的需求来设定，一般来说，如果一个查询需要花费几秒甚至更多的时间来获取结果，那它就可以被认为是慢查询。
慢查询的原因可以有很多，常见的原因包括：
1. **数据库设计不合理**：例如数据冗余过多、表结构不合理等。
2. **缺少适当的索引**：索引可以帮助数据库更快地找到数据。如果没有正确的索引，数据库可能需要全表扫描，这会花费更多的时间。
3. **查询设计不合理**：例如查询使用了复杂的联接、子查询，或者查询条件设计的不合理等。
4. **硬件瓶颈**：如I/O瓶颈，CPU瓶颈等。
5. **数据库系统参数设置不合适**。
对于**慢查询的调优**，通常可以采取以下步骤：
1. **找出问题**：首先，你需要知道哪些查询是慢查询。许多数据库系统提供了慢查询日志，可以帮助你找到执行时间超过一定阈值的查询。
2. **分析问题**：找到慢查询后，你需要分析造成慢查询的原因。工具如MySQL的EXPLAIN命令可以帮助你理解查询的执行计划，如何访问表和索引等。
3. **优化查询**：基于你的分析结果，优化查询。可能的优化措施包括改变查询结构，添加或修改索引，或者改变表的结构。
4. **测试优化效果**：在测试环境中测试你的优化措施，看看是否真的提高了查询的性能。
5. **部署优化**：如果测试结果满意，就可以在生产环境中部署优化。
6. **持续监控**：即使你对查询进行了优化，也需要持续地监控查询的性能，因为数据的变化可能会影响到查询的性能。
### 5、数据库了解吗？说说内连接，左连接，右连接分别是什么？
拿学生表和成绩表来举例。假设学生表的四列分别代表学号，姓名，出生日期和性别。成绩表的三列分别是学号，课程编号和成绩。
学生表 student

|studentId|name|birthDate|sex|
|---|---|---|---|
|001|哈利|1991-01-01|男|
|002|赫敏|1991-05-07|女|
|003|罗恩|1991-09-11|男|
|004|金妮|1996-11-15|女|
成绩表 score

|studentId|courseId|score|
|---|---|---|
|001|C0001|90|
|001|C0002|95|
|002|C0001|100|
|002|C0003|99|
|002|C0004|100|
|005|C0002|92|
两个表都有【studentId】，也就是说，它们是可以通过相同的列【studentId】关联起来。
表连接中最常见的类型就是内连接、左连接和右连接。

|连接类型|关键词|定义|
|---|---|---|
|内连接|(INNER) JOIN|获取两个表中字段匹配关系的记录|
|左连接|LEFT (OUTER) JOIN|获取左表所有记录，右表没有对应匹配的记录时显示为 NULL|
|右连接|RIGHT (OUTER) JOIN|获取右表所有记录，左表没有对应匹配的记录时显示为 NULL
#### 内链接
获取两个表中字段匹配关系的记录，也就是两张表的交集。可以通过主外键关系做为条件来去除无用信息。
![[Pasted image 20240426142102.png]]
语法：
```sql
SELECT * 
FROM <表名1> [表别名1] 
INNER JOIN <表名2> [表别名2]
ON <表别名1>.<外键列>=<表别名2>.<主键列>;
```
拿学生表和成绩表来举例。查询有成绩的学生信息。
SQL 语句为
```sql
SELECT * 
FROM student st
INNER JOIN score sc
ON st.studentId=sc.studentId;
```
#### 左连接
先查询出左表，以左表为主，然后查询右表，右表中满足条件的显示出来，不满足条件的显示 NULL。
![[Pasted image 20240426142348.png]]
语法：
```sql
SELECT * 
FROM <表名1> [表别名1] 
LEFT [OUTER] JOIN <表名2> [表别名2]
ON <表别名1>.<外键列>=<表别名2>.<主键列>;
```
还是拿学生表和成绩表来举例。查询有信息的学生的成绩。
SQL 语句为
```sql
SELECT * 
FROM student st
LEFT JOIN score sc
ON st.studentId=sc.studentId;
```
#### 右连接
先把右表中所有记录都查询出来，以右表为主，然后查询左表，左表中满足条件的显示出来，不满足的显示 NULL。
![[Pasted image 20240426142436.png]]
语法：
```sql
SELECT * 
FROM <表名1> [表别名1] 
RIGHT [OUTER] JOIN <表名2> [表别名2]
ON <表别名1>.<外键列>=<表别名2>.<主键列>;
```
还是拿学生表和成绩表来举例。查询所有有成绩的学生信息。
SQL 语句为
```sql
SELECT * 
FROM student st
RIGHT JOIN score sc
ON st.studentId=sc.studentId;
```
#### 总结
**数据库就是一个以某种有组织的方式存储的数据集合，是存储和管理数据的仓库**。本质上就是存储数据的文件系统。
用户使用数据库管理系统（DBMS）对数据库进行统一管理和控制，保证数据库的安全性和完整性。平常说的数据库一般指代的就是数据库管理系统。
**关系型数据库，比如使用最广泛的 MySQL**，可以使用 SQL 结构化查询语句来进行数据库的操作。
关系型数据库中多表查询中比较常见的表连接形式分别为内连接、左连接和右连接。
- 内连接：通过关键字 (INNER) JOIN 获取两个表中字段匹配关系的记录。可以通过主外键关系做为条件来去除无用信息。
- 左连接：通过关键字 LEFT JOIN 获取左表所有记录。也就是先查询出左表，以左表为主，然后查询右表，右表中满足条件的显示出来，不满足条件的显示 NULL。
- 右连接：通过关键字 RIGHT JOIN 获取右表所有记录。也就是先把右表中所有记录都查询出来，以右表为主，然后查询左表，左表中满足条件的显示出来，不满足的显示 NULL。
### 6、SQL数据库查询表倒数第10个数据
```sql
SELECT *
FROM table_name
ORDER BY primary_key DESC
LIMIT 1 OFFSET 9;
```
解释：
- `SELECT *`：选择返回结果中的所有字段。
- `FROM table_name`：选择要查询的表名。
- `ORDER BY primary_key DESC`：按照倒序方式根据主键字段排序。
- `LIMIT 1`：限制返回结果集中的行数为 1。
- `OFFSET 9`：从结果集中的第 10 行开始返回结果。
需要注意的是该 SQL 语句假定主键字段排序是以倒序方式排列的，如果是顺序排列，则需要将 `ORDER BY` 子句中的 `DESC` 关键字去掉，将 `LIMIT` 子句中的 `OFFSET` 值修改为表中总行数减去 10。
### 7、索引的优缺点，怎么用。联合索引让你选择（最左原则）。最左原则是啥
索引是一种特殊的数据结构，它能够帮助数据库高效地查询数据。索引具有以下优点：
1. **提高查询速度**：索引能够帮助数据库快速定位需要查询的数据，从而提高查询速度。
2. **减少磁盘 I/O**：索引能够减少磁盘 I/O 操作，从而提高查询效率。
3. **加速数据的排序和分组**：索引能够加速数据的排序和分组操作，从而提高数据库的性能。
4. **提高数据的完整性和一致性**：索引可以确保数据的完整性和一致性，从而提高数据的质量。
索引也有以下缺点：
1. **降低更新性能**：索引会增加插入、更新和删除操作的时间成本，因此在对数据库进行频繁的更新操作时，索引可能会降低性能。
2. **占用磁盘空间**：索引需要占用磁盘空间，因此在数据量较大的情况下，索引可能会占用大量的磁盘空间。
3. **资源占用**：索引需要占用计算机的 CPU、内存和磁盘 I/O 等资源，因此在使用索引时需要平衡资源的使用。
在使用索引时，需要考虑以下几点：
1. **选择合适的列作为索引：应该选择那些经常被查询和筛选的列作为索引**。
2. **避免过多的索引：索引过多会导致磁盘空间和内存资源的浪费，因此应该避免过多的索引**。
3. **理解联合索引的最左原则：联合索引是指在多个列上创建的索引。最左原则是指在使用联合索引进行查询时，必须从左往右依次使用索引中的列，并且遵守列的顺序，否则索引将会失效**。
最左原则是指在使用联合索引进行查询时，必须从左往右依次使用索引中的列，并且遵守列的顺序。如果不遵守最左原则，将会导致索引失效，从而降低查询的效率。因此，在使用联合索引时，需要根据最左原则来优化查询语句。
### 8、数据库事务、主键与外键的区别？
数据库事务、主键和外键是关系型数据库中的三个重要概念，它们有以下区别：
1. 数据库事务：事务是指一组数据库操作，这些操作要么全部执行成功，要么全部执行失败。如果其中任何一个操作失败，整个事务都会被回滚，恢复到事务开始之前的状态。事务能够确保数据库的一致性和完整性，防止数据错误和损失。
2. 主键：主键是用于唯一标识一张表中每一行数据的字段或者字段集合。它确保了表中每一行数据的唯一性，通常是通过在该字段上创建唯一索引来实现的。主键能够在表中保证数据的完整性和一致性，而且它还可以用于与其他表进行关联。
3. 外键：外键是一张表中的字段，它与另一张表的主键相关联。外键关系用于连接两张表，保证数据的一致性和完整性。外键的作用是在子表中建立对主表中行的引用，保证了在子表中只能插入在主表中存在的值。外键也可以有多个字段构成。
总结：数据库事务、主键和外键都是关系型数据库中的重要概念，它们有着不同的作用和用途。事务用于保证一组数据库操作的原子性、一致性、隔离性和持久性。主键用于唯一标识每一行数据，外键用于连接两张表的数据。在数据库设计和优化中，正确使用和合理应用这些概念可以提高数据的完整性、一致性和查询效率。
### 9、导致数据库性能差的可能原因有哪些？
数据库性能差的原因可能包括：
1. **硬件资源不足**：如果服务器的硬件（如CPU、内存、磁盘、网络等）不足，可能会导致数据库性能下降。例如，如果磁盘I/O不够，查询和写入数据库就需要更多的时间。
2. **索引不足或不正确**：索引是改善数据库查询性能的重要工具。如果没有正确的索引，数据库需要执行全表扫描，这会花费更多的时间。同样，过度索引也可能导致性能问题，因为每次数据变化时，所有的索引都需要更新。
3. **查询优化不当**：数据库查询可能因为多种原因而没被优化，例如，使用了复杂的联接和子查询，或者查询本身设计不合理。这可能导致数据库花费更多的时间来处理查询。
4. **并发量过大**：如果太多的用户或应用程序同时访问数据库，可能会导致性能问题。特别是当大量的写操作同时发生时，可能会导致锁定问题和性能下降。
5. **数据和日志文件的布局不合理**：如果数据文件和日志文件在同一个磁盘上，会增加I/O操作的数量，从而影响性能。
6. **数据库的配置不合适**：如果数据库的配置参数（如内存分配、并发控制等）不合适，可能会影响数据库性能。
7. **数据库设计不良**：如数据冗余过多、表结构不合理等也会影响数据库性能。
8. **磁盘碎片过多**：数据库中的数据如果过于碎片化，可能会导致查询性能下降。
以上都是可能影响数据库性能的因素，具体情况还需要具体分析，通过监控和诊断工具来找出瓶颈，然后进行相应的优化。
### 10、死锁（悲观锁、乐观锁）及如何解决、读写锁
**死锁**是指两个或更多的处理任务互相等待对方所占有的资源，造成的一种阻塞状态。在数据库中，一个事务在等待另一个事务释放资源，而另一个事务也在等待第一个事务释放资源，形成了循环等待，这就是死锁。
**悲观锁**是指在数据被访问时立即加锁，直到事务结束才释放锁。悲观锁假定数据很可能会被其他事务修改，因此在数据被访问时立即加锁，这样可以确保数据访问的独占性。但这种方式在高并发的情况下，会导致大量的事务堵塞，进而影响系统的性能。
**乐观锁**则与悲观锁相反，它假定数据一般情况下不会发生冲突，所以在访问记录时不会加锁，而是在更新数据时才会检查是否存在其他事务对数据进行了修改。乐观锁适用于读多写少的应用场景，可以降低锁的开销，提高系统的并发能力。
**解决死锁**的方法通常包括以下几种：
1. **设置锁超时**：为数据库设置锁超时时间，超过这个时间仍然不能获得资源的事务将被回滚。
2. **死锁检测**：数据库系统通过死锁检测机制，检测到死锁后，主动打破死锁，通常是终止部分事务，回滚操作，释放资源。
3. **顺序访问资源**：事务访问资源的顺序一致，可以避免死锁。
**读写锁**是一种并发控制机制，允许多个读操作同时进行，但是在写操作执行的时候，必须确保没有其他的读写操作。也就是说，读锁是共享的，写锁是独占的。在实现中，当一个线程进行写操作时会先获取写锁，在此期间，其他的读写操作都会被阻塞；当一个线程进行读操作时，如果没有线程持有写锁，则可以获取读锁进行读操作，否则会被阻塞。在读操作完成后需要释放读锁，写操作完成后需要释放写锁。
### 11、mysql怎么删除表、清空表
在MySQL中，删除表和清空表的命令如下：
**删除表：==如果你要删除整个表，你可以使用 `DROP TABLE` 命令**==。
例如，如果你有一个名为 `myTable` 的表，你想要删除这个表，你可以运行以下命令：
```sql
DROP TABLE myTable;
```
请注意，这将删除整个表，包括表结构和所有的数据。所以在执行这个命令之前，一定要确保你真的要删除这个表。
**清空表：==如果你只是想删除表中的所有数据，但是希望保留表结构（例如列名、数据类型等），你可以使用 `TRUNCATE TABLE` 命令**==。
例如，如果你想清空 `myTable` 表中的所有数据，你可以运行以下命令：
```sql
TRUNCATE TABLE myTable;
```
这个命令将删除表中的所有数据，但是保留表结构。
请注意，==这两个操作都是**不可逆的**==，所以在执行这些命令之前，必须要确保你的操作。如果可能的话，==最好在操作之前备份你的数据==。
### 12、mysql索引的存储结构是怎么设计的？——困难
MySQL主要使用B+树作为索引的数据结构。B+树是一种自平衡的搜索树，可以保持数据有序，这使得在MySQL中实现范围查询和排序非常方便。以下是关于B+树在MySQL索引中的一些关键特性：
1. **所有的叶节点都在同一层**：这为B+树带来了平衡性，保证了在查找数据时的最坏情况性能，同时也提高了在大部分情况下查找的效率。
2. **叶节点包含所有的键值和指向记录的指针**：这使得范围查询更加高效，因为找到范围的开始节点后，只需顺着叶节点层进行扫描即可。
3. **非叶节点不保存数据，只保存子节点的引用**：这使得一个节点可以存储更多的键，从而减少了树的高度，提高了查询速度。
4. **树中的每个节点都包含有序的键和指向子节点的指针**：这使得B+树可以利用二分搜索算法进行高效的键值查找。
MySQL中主要有两种类型的索引，即聚集索引和非聚集索引。聚集索引是按照主键排序存储记录的，因此一张表只能有一个聚集索引。非聚集索引是存储了键值和一个指向实际记录行的指针的索引，一张表可以有多个非聚集索引。
在设计索引时，需要考虑的因素有数据的独特性、查询的类型和频率、数据的大小和分布等，以确保索引可以提高查询性能，而不是成为维护的负担。
### 13、SQL面试题：给一个字段，对其进行从大到小排序，取前十行。
答：`SELECT * FROM 表名称 ORDER BY 字段名称 DESC LIMIT 10;`
### 14、HashMap 和 HashTable 的区别
